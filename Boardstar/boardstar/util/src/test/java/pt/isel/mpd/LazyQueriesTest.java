/*
 * GNU General Public License v3.0
 *
 * Copyright (c) 2020, Miguel Gamboa (gamboa.pt)
 *
 *   All rights granted under this License are granted for the term of
 * copyright on the Program, and are irrevocable provided the stated
 * conditions are met.  This License explicitly affirms your unlimited
 * permission to run the unmodified Program.  The output from running a
 * covered work is covered by this License only if the output, given its
 * content, constitutes a covered work.  This License acknowledges your
 * rights of fair use or other equivalent, as provided by copyright law.
 *
 *   You may make, run and propagate covered works that you do not
 * convey, without conditions so long as your license otherwise remains
 * in force.  You may convey covered works to others for the sole purpose
 * of having them make modifications exclusively for you, or provide you
 * with facilities for running those works, provided that you comply with
 * the terms of this License in conveying all material for which you do
 * not control copyright.  Those thus making or running the covered works
 * for you must do so exclusively on your behalf, under your direction
 * and control, on terms that prohibit them from making any copies of
 * your copyrighted material outside their relationship with you.
 *
 *   Conveying under any other circumstances is permitted solely under
 * the conditions stated below.  Sublicensing is not allowed; section 10
 * makes it unnecessary.
 */

/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package pt.isel.mpd;

import org.junit.Test;
import java.util.*;

import static org.junit.Assert.*;
import static pt.isel.mpd.util.LazyQueries.*;

public class LazyQueriesTest {

    @Test
    public void testGenerateRandomIntegers() {
        Random rand = new Random();
        Iterator<Integer> nrs = generate(rand::nextInt).iterator();
        System.out.println(nrs.next());
        System.out.println(nrs.next());
        System.out.println(nrs.next());
    }

    int init;
    @Test
    public void testGenerateEvenIntegers() {
        Iterator<Integer> expected = Arrays.asList(0, 2, 4, 6).iterator();
        init = 0;
        Iterable<Integer> actual = limit(filter(generate(() -> init++), n -> n % 2 == 0), 4);
        actual.forEach(curr -> assertEquals(expected.next(), curr));
        assertFalse(expected.hasNext());
    }

    @Test
    public void filterEvenNumbers() {
        Iterable<Integer> nrs = Arrays.asList(1, 2, 3, 4, 5, 6, 7);
        Iterator<Integer> expected = Arrays.asList(2, 4, 6).iterator();
        Iterator<Integer> actual = filter(nrs, n -> n % 2 == 0).iterator();
        while(actual.hasNext()) {
            Integer curr = actual.next();
            assertEquals(expected.next(), curr);
        }
        assertFalse(expected.hasNext());
    }

    @Test
    public void testCount() {
        Iterable<Integer> nrs = Arrays.asList(1, 2, 3, 4, 5, 6, 7);
        int count = count(nrs);
        assertEquals(7, count);
    }

    @Test
    public void testLimit() {
        List<Integer> ns = Arrays.asList(1, 2, 3, 4, 5, 6, 7);
        Iterable<Integer> actual = limit(ns, 5);
        assertEquals(5, count(actual));
    }

    @Test
    public void testSkip() {
        List<Integer> nrs = Arrays.asList(1, 2, 3, 4, 5, 6, 7);
        Object[] actual = toArray(skip(nrs, 2));
        Object[] expected = {3, 4, 5, 6, 7};
        assertArrayEquals(expected, actual);
    }

    @Test
    public void testMap() {
        List<Integer> numbers = Arrays.asList(2, 4, 6, 8, 10);
        Object[] actual = toArray(map(numbers, n -> n / 2));
        Object[] expected = {1, 2, 3, 4, 5};
        assertArrayEquals(expected, actual);
    }

    @Test
    public void TestFilter() {
        List<Integer> nrs = Arrays.asList(1, 2, 2, 2, 2, 3, 4, 5, 6, 7);
        Object[] actual = toArray(filter(nrs, n -> n != 2));
        Object[] expected = {1, 3, 4, 5, 6, 7};
        assertArrayEquals(expected, actual);
    }

    @Test
    public void testIterate() {
        Iterable<Integer> seq = iterate(1, n -> n + 1);
        Iterable<Integer> iter = limit(map(seq, n -> n * n), 7);
        int nmr = 1;
        for (int i : iter) {
            assertEquals(nmr * nmr, i);
            nmr++;
        }
    }

    @Test
    public void testToArray() {
        Iterable<Integer> list = Arrays.asList(1, 2, 3, 4, 5, 6, 7);
        Object[] actual = toArray(list);
        int i = 0;
        for (Object obj : list) {
            assertEquals(obj, actual[i++]);
        }
    }

    @Test
    public void testMax() {
        Iterable<Integer> list = Arrays.asList(1, 2, 3, 8, 5, 6, 7);
        assertEquals(Optional.of(8), max(list));
    }

    @Test
    public void testFirst() {
        Iterable<Integer> list = Arrays.asList(1, 2, 3);
        assertEquals(Optional.of(1), first(list));
    }

    @Test
    public void testLast() {
        Iterable<Integer> list = Arrays.asList(1, 2, 3);
        assertEquals(Optional.of(3), last(list));
    }

    @Test
    public void testTakeWhile() {
        List<Integer> list = Arrays.asList(1, 2, 3, 4, 5, 6, 7);
        Iterable<Integer> actual = takeWhile(list, n -> n < 4);
        Object[] arrayActual = toArray(actual);
        Object[] expected = {1, 2, 3};
        assertArrayEquals(expected, arrayActual);
    }

    @Test
    public void testFlatMap() {
        List<String> words = Arrays.asList("super", "isel", "", "ola", "");
        Iterable<Character> letters = flatMap(words,
                l -> {
                    LinkedList<Character> characters = new LinkedList<>();
                    for (Character letter : l.toCharArray())
                        characters.add(letter);
                    return characters;
                });
        Object[] actual = toArray(letters);
        Object[] expected = {'s', 'u', 'p', 'e', 'r', 'i', 's', 'e', 'l', 'o', 'l', 'a'};
        assertArrayEquals(expected, actual);
    }
}
